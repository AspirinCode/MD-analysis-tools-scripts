#!/usr/bin/env python
from __future__ import print_function
import argparse
import sys
import networkx as nx
import re
import numpy as np
import itertools

_s = re.compile('\s+')
_p = re.compile('(\d+)\s+(\d+)')

def lsqp(atoms):
    com = atoms.mean(axis=0)
    #u, d, v = np.linalg.svd(atoms-com)

    axes = np.zeros((len(atoms), 3))
    for i in range(len(atoms)):
        p1 = atoms[i]
        if i == len(atoms)-1:
            p2 = atoms[0]
        else:
            p2 = atoms[i+1]
        a = np.cross(p1, p2)
        axes += a
    u, d, v = np.linalg.svd(axes)
    i = 0
    d = -np.dot(v[i], com)
    n = -np.array((v[i,0], v[i,1], d))/v[i,2]
    return v[i], com, n

def intriangle(triangle, axis, u, p):
    # http://www.softsurfer.com/Archive/algorithm_0105/algorithm_0105.htm
    p1, p2, p3 = triangle
    w0 = p - p1
    a = -np.dot(axis, w0)
    b = np.dot(axis, u)
    if (abs(b) < 0.01): return False

    r = a / b
    if r < 0.0: return False
    if r > 1.0: return False

    I = p + u * r

    u = p2 - p1
    v = p3 - p1
    uu = np.dot(u, u)
    uv = np.dot(u, v)
    vv = np.dot(v, v)
    w = I - p1
    wu = np.dot(w, u)
    wv = np.dot(w, v)
    D = uv * uv - uu * vv

    s = (uv * wv - vv * wu)/D
    if (s < 0 or s > 1): return False
    t = (uv * wu - uu * wv)/D
    if (t < 0 or (s+t) > 1): return False
    return True

def build_topology(psffile):
    g = nx.Graph()
    flag = 0

    for line in open(psffile).readlines():
        if flag == 0 and line.strip().endswith('NATOM'):
            natom = int(line.strip().split()[0])
            g.natom = natom
            flag = 1
            continue
        if flag == 0 and line.strip().endswith('bonds'):
            flag = 2
            continue
        if flag == 1 and not line.strip(): flag = 0
        if flag == 2 and not line.strip(): break

        if flag == 1:
            num, segid, resid, resname, name = _s.split(line)[1:6]
            if resname.startswith('TIP3'): continue
            if name.startswith('H'): continue
            g.add_node(int(num), {'segid': segid, 'resname': resname, 'name': name, 'resid': resid})

        if flag == 2:
            for pair in _p.findall(line):
                num1, num2 = map(int, pair)
                if g.has_node(num1) and g.has_node(num2): g.add_edge(num1, num2)
    return g

def build_atomtable(psf, crdfile):
    crds = {}
    flag = 0
    for line in open(crdfile).readlines():
        if line.startswith('*'): continue
        if flag == 0:
            flag = 1
            continue
        if flag == 1 and not line.strip(): break

        if flag == 1:
            num, resid, resname, name, x, y, z, segid = _s.split(line.strip())[:8]
            if resname.startswith('TIP3'): continue
            if name.startswith('H'): continue
            if psf.node[int(num)]['name'] != name: raise AtomMismatch("%d %s != %d %s" % (int(num), psf.node[int(num)]['name'], int(num), name))
            crds[int(num)] = np.array((float(x), float(y), float(z)))
    return crds

class AtomMismatch(Exception):
    pass

def check_ring_penetration(psf, crd, pbc=[], xtl='rect', verbose=0):
    # ring penetration test
    # 1. find rings
    # 2. build least square plane
    # 3. project atoms ring constituent atoms onto the plane and build convex
    # 4. find two bonded atoms that are at the opposite side of the plane
    # 5. determine the point of intersection is enclosed in the ring
    #
    molecules = nx.connected_component_subgraphs(psf)
    allatoms = np.array([crd[num] for num in psf.nodes()])
    atoms_map = np.array([num for num in psf.nodes()])
    natoms = len(allatoms)
    if pbc:
        atoms_map_reverse = {}
        for i,num in enumerate(psf.nodes()):
            atoms_map_reverse[num] = i

        a = float(pbc[0])
        b = float(pbc[1])
        n = len(allatoms)
        if xtl == 'rect':
            allatoms = np.tile(allatoms, (9,1))
            op = ((a,0),(a,b),(0,b),(-a,b),(-a,0),(-a,-b),(0,-b),(a,-b))
            for i in range(8):
                x,y = op[i]
                allatoms[n*(i+1):n*(i+2),0] += x
                allatoms[n*(i+1):n*(i+2),1] += y
            atoms_map = np.tile(atoms_map, 9)
        if xtl =='hexa':
            allatoms = np.tile(allatoms, (7,1))
            rot = lambda theta: np.matrix(((np.cos(np.radians(theta)), -np.sin(np.radians(theta))),
                                           (np.sin(np.radians(theta)),  np.cos(np.radians(theta)))))
            op = (rot(15), rot(75), rot(135), rot(195), rot(255), rot(315))
            d = np.array((a, 0))
            for i in range(6):
                xy = np.dot(d, op[i])
                allatoms[n*(i+1):n*(i+2),:2] = allatoms[n*(i+1):n*(i+2),:2] + xy
            atoms_map = np.tile(atoms_map, 7)

    # print out image atoms
    #fp = open('image.pdb', 'w')
    #for i,atom in enumerate(allatoms):
    #    x, y, z = atom
    #    fp.write("HETATM%5d  %-3s %3s  %4d    %8.3f%8.3f%8.3f  0.00  0.00      \n" % (i, 'C', 'DUM', i, x, y, z))

    pen_pairs = []
    pen_cycles = []

    for m in molecules:
        cycles = nx.cycle_basis(m)
        if not cycles: continue
        for cycle in cycles:
            flag = False
            atoms = np.array([crd[num] for num in cycle])
            if len(set([psf.node[num]['resid'] for num in cycle])) > 1: continue
            if verbose:
                num = cycle[0]
                print('found ring:', psf.node[num]['segid'], psf.node[num]['resid'], psf.node[num]['resname'])

            # build least square fit plane
            axis, com, n = lsqp(atoms)

            # project atoms to the least square fit plane
            for i,atom in enumerate(atoms):
                w = np.dot(axis, atom-com)*axis + com
                atoms[i] = com + (atom - w)

            maxd = np.max(np.sqrt(np.sum(np.square(atoms - com), axis=1)))

            d = np.sqrt(np.sum(np.square(allatoms-com), axis=1))
            nums = np.squeeze(np.argwhere(d < 3))

            # find two bonded atoms that are at the opposite side of the plane
            for num in nums:
                num1 = atoms_map[num]

                for num2 in psf[num1]:
                    if num1 in cycle or num2 in cycle: continue
                    if num > natoms:
                        # image atoms
                        offset = int(num / natoms)
                        crd1 = allatoms[num]
                        crd2 = allatoms[atoms_map_reverse[num2] + offset * natoms]
                    else:
                        crd1 = crd[num1]
                        crd2 = crd[num2]

                    v1 = np.dot(crd1 - com, axis)
                    v2 = np.dot(crd2 - com, axis)
                    if v1 * v2 > 0: continue

                    # point of intersection of the least square fit plane
                    s = -np.dot(axis, crd1-com)/np.dot(axis, crd2-crd1)
                    p = crd1 + s*(crd2-crd1)

                    d = np.sqrt(np.sum(np.square(p-com)))
                    if d > maxd: continue
                    if verbose:
                        print('found potentially pentrarting bond:', psf.node[num1]['segid'], psf.node[num1]['resid'], psf.node[num1]['resname'], psf.node[num1]['name'], psf.node[num2]['name'])

                    d = 0
                    for i in range(0, len(atoms)):
                        p1 = atoms[i] - p
                        try: p2 = atoms[i+1] - p
                        except: p2 = atoms[0] - p
                        d += np.arccos(np.dot(p1, p2)/np.linalg.norm(p1)/np.linalg.norm(p2))

                    wn = d/2/np.pi
                    if wn > 0.9 and wn < 1.1:
                        # we have a case
                        pen_pairs.append((num1, num2))
                        pen_cycles.append(cycle)
                        flag = True
                        break

                if flag: break

    return pen_pairs, pen_cycles

def find_alpha_shape(atoms, alpha=-1, verbose=0):
    # build alpha-shape of the protein
    # requires Ken Clarkson's Hull program
    # http://netlib.sandia.gov/voronoi/hull.html
    import subprocess as sp
    pid = sp.Popen([hull, '-A', '-oN'], stdin=sp.PIPE, stdout=sp.PIPE, stderr=sp.PIPE, close_fds=True) # Delaunay triangulation
    pid.communicate("\n".join(["%12.8f %12.8f %12.8f" % tuple(atom) for atom in atoms]))

    flag = False
    facets = []
    facets_crds = []
    vertices = set([])
    h = nx.Graph()
    for line in open('hout-alf').readlines():
        if flag:
            i, j, k = map(int, line.strip().split())
            facets.append((i, j, k))
            facets_crds.append(np.array((atoms[i], atoms[j], atoms[k])))
            [vertices.add(x) for x in (i,j,k)]
            h.add_edges_from([(i, j), (i, k), (j, k)])
        if line.startswith("%") and 'hull' in line: flag = True
    facets_crds = np.array(facets_crds)
    return h, facets_crds

def check_protein_penetration(psf, crds, verbose=0, output=0):
    # protein penetration test
    # 1. build alpha-shape of the protein based on the CA and CB atoms within 6A
    # 2. find two atoms that placed opposite side of the hull
    #

    prot_atoms = np.array([crds[num] for num in psf.nodes() if psf.node[num]['name'] in ['CA', 'CB']])
    prot_segids = set([psf.node[num]['segid'] for num in psf.nodes() if psf.node[num]['name'] == 'CA'])
    pen_pairs = []
    if len(prot_atoms) == 0: return pen_pairs

    g, facets_crds = find_alpha_shape(prot_atoms, verbose)

    if output:
        fp = open(output, 'w')
        for node in g.nodes():
            x, y, z = prot_atoms[node]
            fp.write("HETATM%5d  %-3s %3s  %4d    %8.3f%8.3f%8.3f  0.00  0.00      \n" % (node, 'C', 'DUM', node, x, y, z))

        for edge in g.edges():
            fp.write("CONECT%5d%5d\n" % edge)

    dist = lambda x,y: np.sqrt(np.sum(np.square(x - y)))
    flag = False

    # find atoms potentially protruding the alpha-surface of the protein
    xmax, xmin = np.max(prot_atoms[:,0]), np.min(prot_atoms[:,0])
    ymax, ymin = np.max(prot_atoms[:,1]), np.min(prot_atoms[:,1])
    visited = []
    for node in psf.nodes():
        if psf.node[node]['segid'] in prot_segids: continue
        if node in visited: continue
        crd = crds[node]
        if ((crd[0] > (xmax+3) or crd[0] < (xmin-3)) and
            (crd[1] > (ymax+3) or crd[1] < (ymin-3))): continue
        if np.min(np.sum(np.square(facets_crds[:,0]-crd), axis=1)) > 25: continue

        # closest facet
        d = np.sum(np.square((np.sum(facets_crds, axis=1)/3) - crd), axis=1)
        if np.min(d) > 3: continue
        close_facets = np.argwhere(d < 3)
        if len(close_facets) == 0: continue
        close_facets = np.reshape(close_facets, (len(close_facets)))

        num1 = node
        u = []
        crd1 = np.array(crds[num1])
        for num2 in psf[num1]:
            crd2 = np.array(crds[num2])
            u.append((num2, crd2-crd1))

        flag = False
        for i in close_facets:
            facet = facets_crds[i]
            p1 = np.array(facet[0])
            p2 = np.array(facet[1])
            p3 = np.array(facet[2])
            triangle = np.array((p1, p2, p3))
            axis = np.cross(p2-p1, p3-p1)

            for num2, r in u:
                if not intriangle(triangle, axis, r, crd1): continue
                else:
                    # we have a case
                    pen_pairs.append((num1, num2))
                    visited.append(num1)
                    visited.append(num2)
                    flag = True
                    break
            if flag: break

    return pen_pairs

def main():
    global hull

    parser = argparse.ArgumentParser()
    parser.add_argument('psf', metavar='psffile', help='PSF file')
    parser.add_argument('crd', metavar='crdfile', help='CRD file')
    parser.add_argument('-xtl', dest='xtl', choices=['rect', 'hexa'], help='PBC option (rect or hexa)', default='rect')
    parser.add_argument('-pbc', dest='pbc', nargs=2, help='PBC option (A and B values)')
    parser.add_argument('-v', dest='verbose', action='store_true')
    parser.add_argument('-o', dest='output', help='Visualize alpha shape', default=None)
    parser.add_argument('-hull', dest='hull', help='Path for hull program', default='/home/charmm-gui/local/bin/hull')
    args = parser.parse_args()
    hull = args.hull

    # build connectivity of atoms
    psf = build_topology(args.psf)
    crd = build_atomtable(psf, args.crd)

    # sanity check
    if len(psf.nodes()) != len(crd): raise AtomMismatch('Number of atom does not match')

    print('%lipid ring penetration')
    pairs, rings = check_ring_penetration(psf, crd, pbc=args.pbc, xtl=args.xtl, verbose=args.verbose)
    if pairs:
        #print 'found a ring penetration:'
        for i, cycle in enumerate(rings):
            print('- %s %s %s %s | %s %s %s %s' % (psf.node[pairs[i][0]]['segid'], psf.node[pairs[i][0]]['resid'], psf.node[pairs[i][0]]['resname'], ' '.join([psf.node[num]['name'] for num in pairs[i]]), psf.node[cycle[0]]['segid'], psf.node[cycle[0]]['resid'], psf.node[cycle[0]]['resname'], ' '.join([psf.node[num]['name'] for num in cycle])))

    print('%protein surface penetration')
    pairs = check_protein_penetration(psf, crd, verbose=args.verbose, output=args.output)
    if pairs:
        #print 'found a protein penetration:'
        for pair in pairs:
            print('- %s %s %s %s %s' % (psf.node[pair[0]]['segid'], psf.node[pair[0]]['resid'], psf.node[pair[0]]['resname'], psf.node[pair[0]]['name'], psf.node[pair[1]]['name']))


if __name__ == '__main__':
    main()
 
